# 1. 클래스와 데이터

```java
/**
 * 클래스를 사용하면 int, String과 같은 타입을 직접 만들 수 있다 --> 클래스 생성 == 타입 생성
 * 사용자가 직접 정의하는 사용자 정의 타입을 만드려면 설계도가 필요하다. -> 이 설계도가 바로 클래스
 * 설계도를 기반으로 실제 메모리에 만들어진 실체를 객체 또는 인스턴스라고 한다. (객체 == 인스턴스)
 * Student student1 = new Student()
 * -> student1 변수는 이제 메모리에 존재하는 Student 객체(인스턴스)의 참조값을 가지고 있음. 
 */
public class Student {
    /**
     * 클래스에 정의한 변수들을 멤버 변수 또는 필드라고 함
     * 멤버변수 : 특정 클래스에 소속된 멤버라는 의미
     * 필드 : 데이터 항목을 가르키는 전통적인 용어. DB,엑셀 등에서 데이터 각각의 항목을 필드라고 한다.
     * 자바에서 멤버변수, 필드는 같은 뜻. 클래스에 소속된 변수.
     */
    String name;
    int age;
    int grade;
}
```
## 클래스, 객체, 인스턴스 정리
- 클래스 
- -> 속성(변수)와 기능(메서드)를 정의
- 객체 vs 인스턴스
- -> 구분을 안해도 괜찮지만 구분을 해보면, 
- -> '모든 인스턴스는 객체이지만, 우리가 인스턴스라고 부르는 순간은 특정 클래스로부터 그 객체가 생성되었음을 강조하고 싶을 때'

## 배열 도입
![](img/img.png)
- 자바에서 대입은 항상 변수에 들어 있는 값을 복사해서 전달한다
```
students[0] = student1; // students[0] = x001;
students[1] = student2; // students[1] = x002;
```
- 주의) 변수에는 인스턴스 자체가 들어있는 것이 아님! 인스턴스의 위치를 가리키는 참조값이 들어있을 뿐. 따라서 대입(=)인스턴스가 복사되는 것이 아니라 참조값만 복사됨.

# 2. 기본형과 참조형
- 기본형 : 변수에 사용할 값을 직접 넣음
- 참조형 : 변수에 데이터에 접근하기 위한 참조(메모리 주소)를 저장. 참조형은 객체 또는 배열에 사용
## 기본형과 참조형 - 메서드 호출
- 메서드를 호출할 때 사용하는 매개변수(파라미터)도 결국 변수. 
- -> 따라서 메서드를 호출할 때 매개변수에 값을 전달하는 것도 앞서 설명한 내용과 같이 값을 복사해서 전달한다. 
```java
public class MethodChange1 {
    public static void main(String[] args) {
        int a = 10;
        System.out.println("메서드 호출 전 : a =" + a); // 10
        changePrimitive(a);
        System.out.println("메서드 호출 후 :  a = " + a); // 10
    }

    public void changePrimitive(int x) {
        x = 20; //주소가 아니라 값이 전달됨
    }
}

public class MethodChange2 {
    public static void main(String[] args) {
        Data dataA = new Data();
        dataA.value = 10;
        System.out.println("메서드 호출 전 : dataA.value =" + dataA.value); // 10
        changeReference(dataA);
        System.out.println("메서드 호출 후 :  dataA.value = " + dataA.value); // 20
    }

    public void changeReference(Data dataX) {
        dataX.value = 20; //주소가 아니라 값이 전달됨
    }
}
```

## 변수와 초기화
### 변수의 종류
- 멤버변수(필드) : 클래스에 선언
- 지역변수 : 메서드에 선언. 매개변수도 지역변수의 한 종류이다. 
### 변수의 초기화
- 멤버변수(필드) : 자동초기화
- -> 인스턴스를 생성할 때 자동 초기화됨
- -> 숫자(int) = 0, boolean=false, 참조형=null, (null값은 참조할 대상이 없다는 뜻임) 
- -> 개발자가 초기값을 지정할 수 있다
- 지역변수 : 수동초기화
- 지역변수는 항상 직접 초기화해야한다. 
### null
- 참조형 변수에는 항상 객체가 있는 위치를 가리키는 참조값이 들어감
- 하지만 아직 가리키는 대상이 없거나 가리키는 대상을 나중에 입력하고 싶은 경우라면?
- -> 참조형 변수에 null 이라는 특별한 값을 넣어둘 수 있다.
- -> null은 값이 존재하지 않는, 없다는 뜻이다. 
cf) CG - 아무도 참조하지 않는 자의 최후..
- 인스턴스를 아무도 참조하지 않을 때 
- -> 해당객체를 참조하는 곳이 모두사라지면 JVM은 필요없는 객체로 판단하고 GC를 통해 제거함 
### NullPointerException
- 참조값 없이 객체를 찾아가려고 하면 발생하는 예외
```java
class BigData{
    Data data;
    int count;
}
class Main{
    public static void main(String[] args) {
        BigData bigData = new BigData();
        System.out.println(bigData.data); //null (출력됨) <- 멤버변수 초기화
        System.out.println(bigData.count); //0 <- 멤버변수 초기화
        System.out.println(bigData.data.value); // NullPointerException !
    }
}
```
- 정리 : NullPointerException이 발생하면 null 값에 .(점) 을 찍었다고 생각하기! 

# 3. 객체지향 프로그래밍
### 클래스와 메서드
- 객체지향언어는 클래스 내부에 속성(데이터)과 기능(메서드)을 함께 포함할 수 있다.
```java
class Main{
    public static void main(String[] args) {
        ValueObject valueObject = new ValueObject();
        valueObject.add(); // 1
        valueObject.add(); // 2
    }
}
class ValueObject{
    int value;
    void add(){
        value++;
    }
}
```
- add()를 호출하면 메서드 내부에서 value++를 호출하게 된다. 이때 value에 접근해야하는데, 
- -> 기본적으로 본인 인스턴스에 있는 멤버변수에 접근한다. 본인 인스턴스가 x002를 가지면 x002.value에 접근

# 4. 생성자 
- 객체를 생성하는 시점에 어떤 작업을 하고 싶다면 생성자를 이용하면된다.
- 목표) 객체지향관점에서 속성과 기능을 한곳에 두기 <- 데이터 세팅 메서드를 객체에 두는 느낌
```java
class Main{
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit(); //기존
        initMember(member1);
    }
    // .. initMember(){} -> 속성과 기능이 분리되어있다..
}
```
## this
```java
public class MemberInit {
    String name;
    int age;
    int grade;

    void initMember(String name, int age, int grade) {
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
class Main{
    public static void main(String[] args) {
        MemberInit member1 = new MemberInit(); //기존
        member1.initMember("이름", 10, 5);
    }
}
```
### this 설명
- this: 메서드의 매개변수와 멤버변수이름이 같을 때, **메서드 내부에서는 메서드 매개변수의 스코프가 더 가깝기 때문에 매개변수가 우선.**
- -> 멤버변수에 접근하기 위해 변수앞에 this.를 붙인다. 여기서 this.는 현재 인스턴스의 참조값을 가리킨다. 

### this의 생략
- this는 생략 가능. 
- -> 변수를 찾을 떄 가까운 지역변수(매개변수도 지역변수) 를 먼저 찾고 그 다음으로 멤버변수를 찾음
- -> 멤버변수도 없을 경우 에러
- this를 무조건 사용하는 코딩스타일이 있지만 최근에는 잘 쓰지 않음

## 생성자 - 도입
- 객체를 생성하고 이후에 바로 초기값을 할당해야하는 경우가 많음 
- -> 앞서 initMember() 같은 메서드를 매번 만들어야함
- -> 생성자 사용 -> 생성자를 사용하면 객체를 생성하는 시점에 즉시 필요한 기능을 수행할 수 있다.
- 장점)
- -> 중복호출 제거, 
- -> 제약-생성자 호출 필수 - 초기값 할당을을 실수로 호출하지 않는 경우 방지

## 기본생성자
- 매개변수가 없는 생성자를 기본 생성자라한다
- **클래스에 생성자가 하나도 없으면 자바 컴파일러는 매개변수가 없고, 작동하는 코드가 없는 기본 생성자를 자동으로 만들어준다.** 
- 생성자가 하나라도 있으면 자바는 기본 생성자를 만들지 않는다. 

## 생성자 - 오버로딩과 this()
```java
public class MemeberConstruct{
    String name;
    int age;
    int grade;
    MemeberConstruct(String name, int age){
        this(name, age, 50); // <<- 생성자 this 활용하여 코드 중복 방지 !! (생성자 코드의 첫줄에서만 작성 가능)
    }
    MemeberConstruct(String name, int age, int grade){
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```
 
# 5 패키지
- 다른 패키지의 같은 클래스명 사용하는 경우
```java
package pack;

import pack.a.User;
        
public class PackageMain{
    public static void main(String[] args) {
        User userA = new User();
        pack.b.User userB = new pack.b.User();
    }
}
```
## 패키지 규칙
- 패키지 이름은과 위치는 폴더 위치와 같아야한다. 
- 패키지 이름은 모두 소문자를 사용한다 (관례)
- 패키지 이름은의 앞 부분에는 일반적으로 회사의 도메인 이름을 거꾸로 사용한다.  

# 6. 접근제어자
## 접근제어자 종류
- private : 모든 외부 호출을 막는다
- default(package-private) : 같은 패키지 안에서 호출은 허용한다.
- protected : 같은 패키지 안 || **패키지 달라도 상속관계 호출 허용**
- public : 모든 외부 호출 허용
- private -> default -> protected -> public (외부 호출 범위 순서)
## 접근제어자 사용 위치
- 접근제어자는 **필드, 메서드, 생성자**에서 사용
- 추가로 **클래스 레벨에도 일부 접근제어자 사용**할 수 있다.
```java
public class Speaker{ // 클래스레벨
    private int volume; // 필드
    public Speaker(int volume) {} // 생성자
    public void volumeUp(){ // 메서드
    } 
}
```
## 접근제어자 사용 - 클래스 레벨
- 클래스 레벨 접근제어자 규칙
- -> public, default만 사용가능 (private, protected 불가)
- -> **public 클래스는 반드시 파일명과 이름이 같아야한다.**
- --> 하나의 자바 파일에는 public 클래스 하나만 가능
- --> 하나의 자바 파일에 default 접근제어자 클래스 여러개 가능

## 캡슐화
- 캡슐화는 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제한하는 것을 말한다.
- -> **속성과 기능을 하나**로 묶고, 외부에 꼭 **필요한 기능만 노출**하고 나머지는 모두 내부로 숨기는 것
- --> 1. 데이터 모두 숨기기, 2. 기능 필요한 것만 노출하기
  - --> 접근 제어자와 캡슐화를 통해 데이터를 안전하게 보호하고, 사용하는 개발자 입장에서 해당 기능을 사용하는 복잡도를 낮츨 수 있다.

# 7. 자바 메모리 구조와 static
## 자바 메모리 구조
![](img/img_1.png)
- 자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역 3개로 나눌 수 있음
- 메서드 영역 : 클래스 정보를 보관. (클래스 정보가 붕어빵 틀)
- 스택 영역 : 실제 프로그램이 실행되는 영역. 메서드를 실행할 때마다 하나씩 쌓인다
- 힙 영역 : 객체(인스턴스)/배열이 생성되는 영역. new 명령어를 사용하면 이 영역을 사용함. (붕어빵이 존재하는 공간)
![](img/img_2.png)
### 메서드 영역
- 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리함. 이 영역은 프로그램의 모든 영역에서 공유함
- 1. 클래스 정보 : 클래스의 실행코드(바이트 코드), 필드, 메서드와 생성자 코드 등 모든 실행 코드가 존재함.
- 2. static 영역 : static 변수들을 보관함. 
- 3. 런타임 상수 풀 : 프로그을 실행하는데 필요한 공통 리터럴 상수를 보관함. 
- -> 프로그램에 "hello"라는 리터럴 문자가 있으면 이런 문자를 공통으로 묶어서 관리. 이외에도 프로그램 관리 위한 상수 관리

### 스택 영역 
- 자바 실행 시 하나의 실행 스택이 생성된다. 
- 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
- -> 정리) 자바는 **스택 영역을 사용해서 메서드 호출과 지역변수(매개변수 포함)을 관리**한다.
- 스택 프레임 : 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임이다. 
- -> 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면, 해당 스택프레임이 제거된다. 
- cf) 스택 영역은 더 정확히는 각 쓰레드별로 하나의 실행 스택이 생성됨. 따라서 쓰레드 수 만큼 스택영역이 생성됨.

### 힙 영역
- 객체(인스턴스)와 배열이 생성되는 곳. 가비지 컬렉션이 이루어지는 주요 영역. 더 이상 참조되지 않는 객체는 GC에 의해 제거됨.
- -> 멤버 변수(필드)는 힙 영역 vs 지역변수(매개변수포함)은 스택 영역
- cf) 힙 영역 안에서만 인스턴스끼리 서로 참조하는 경우에도 GC 대상.

### 메서드 코드는 메서드 영역에
![](img/img_3.png)
- 같은 클래스로부터 생성된 객체라도 인스턴스 내부의 변수 값은 서로 다를 순 있지만, **메서드는 공통된 코드를 공유**한다.
- -> 따라서 객체가 생성될 때 인스턴스 변수에는 메모리가 할당되지만, 메서드에 대한 새로운 메모리 할당은 없다
- -> 메서드는 메서드 영역에서 공통으로 관리되고 실행된다 
- -> 정리하면, 인스턴스의 메서드를 호출하면 실제로는 메서드 영역에 있는 코드를 불러와서 수행한다. 

## static 변수
```java
public class Data3{
    public String name;
//    public int count;
    public static int count; //Data3 클래스가 몇개 생성되는지 알기위한 스태틱(정적)변수
    public Data3(String name){
        this.name = name;
        count++; //Data3.count 도 가능 
    }
}
```
- 멤버변수에 static 을 붙이게되면 static변수, 정적변수 또는 클래스변수라고 한다.
![](img/img_4.png)
- static이 붙은 멤버변수는 **메서드 영역**에서 관리한다.
- 클래스명.변수명으로 접근
- 자신의 클래스에 있는 정적변수라면 클래스명 생략가능
- -> static 변수를 사용한 덕분에 공용 변수를 사용할 수 있게 됨

### 용어정리
```java
public class Data3{
    public String name; //멤버변수(인스턴스변수)
    public static int count; //멤버변수(클래스변수)
}
```
- name, count 둘 다 멤버변수이다. 
#### 멤버변수(필드)의 종류
- 인스턴스 변수: static이 붙지 않은 멤버변수.
- -> static이 붙지 않은 멤버변수는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있다. 
- -> 인스턴스 변수는 인스턴스를 만들 때마다 새로 만들어진다
- 클래스 변수 : static이 붙은 멤버 변수 
- -> 클래스변수, 정적변수, static 변수 등으로 부른다. 
- -> static이 붙은 멤버변수는 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어있다. 
- -> 클래스 변수는 자바 프로그램을 시작할 때 딱 1개가 만들어진다. 인스턴스와 다르게 공유할 목적으로 사용된다.

### 변수와 생명주기
- 지역변수(매개변수 포함)
- -> 스택영역에 있는 스택 프레임에 보관됨. 메서드가 종료되면 스택프레임도 제거되는데, 이떄 해당 스택 프레임에 포함된 지역변수도 함께 제거됨
- 인스턴스변수
- -> 인스턴스 변수는 힙 영역을 사용. GC가 발생되기 전까지 생존하기 때문에 보통 지역변수보다 생존주기가 김
- 클래스변수 
- -> **메서드영역의 static영역**에 보관됨. 메서드영역은 프로그램 전체에서 사용되는 공용공간
- -> **클래스 변수는 해당 클래스가 JVM에 로딩되는 순간에 생성**됨
- -> JVM이 종료될 때까지 생명주기가 이어져서 가장 긴 생명주기 갖음
- --> **static이 정적**이라는 이유가 여기에 있다. 프로그램 시작 시 한 번 생성되고 종료 시 제거되므로 정적이다. 

## static 메서드
```java
public class DecoUtil1{
    public String deco(String str){
        return "*" + str + "*";
    }
}
```
- 위의 코드는 deco()를 호출하기 위해 DecoUtil1 인스턴스를 먼저 생성해야함
- -> 그런데 DecoUtil 클래스는 멤버변수도 없고 deco()라는 기능만 제공함
- -> **인스턴스가 필요한 이유는 멤버변수를 사용하는 목적**이 제일 큼
- --> static 키워드를 붙이면 인스턴스 생성 필요 없이 클래스로 메서드 바로 접근 가능

### 클래스 메서드 vs 인스턴스 메서드
- 클래스 메서드 : 메서드 앞에 static 키워드. 정적 메서드 혹은 클래스 메서드라 함. 인스턴스 생성없이 바로 접근가능 
- 인스턴스 메서드 : static이 붙지 않은 메서드. 인스턴스를 생성해야 호출가능. 








